\section*{Ejercicio 2}

Explique detalladamente el rol que juega el invariante de representación en el diseño jerárquico de tipos abstractos de datos. Relaciónelo con el concepto de complejidad algorítmica.

El invariante de representación nos permite determinar si una instancia de la estructura de representación es válida o no. La estructura contiene toda la información necesaria para observar la instancia del TAD y poder realizar sus operaciones.

En todas las funciones de la interfaz se asume que el invariante vale en la Pre y en la Post. No necesariamente tiene que valer en el medio de la función, ni en funciones auxiliares que no son exportadas (no están en la interfaz).

¿De qué nos sirve esto? El invariante nos garantiza ciertas propiedades de la estructura que nos permiten diseñar algoritmos eficientes. Por ejemplo, el invariante de un AVL solo permite un factor de desbalanceo $F$ tal que $|F| \leq 1$ y esto es fundamental para poder garantizar la complejidad $O(log(n))$ de sus operaciones. Como el invariante vale en la Pre, los algoritmos de búsqueda, inserción y borrado pueden apoyarse en esta propiedad para asumir el estado inicial del árbol antes de la operación. Es importante que también valga en la Post para que la propiedad siga valiendo en futuras operaciones.

No siempre se trata de garantizar una propiedad interesante para lograr algoritmos eficientes. A veces simplemente tenemos que garantizar que la estructura sea ``coherente''. Por ejemplo, supongamos una estructura para un TAD que modela un supermercado con productos, donde tenemos los productos guardados de varias formas: un diccionario sobre un trie que mapea producto $\to$ precio, y un conjunto de productos en oferta. El invariante debe garantizar que los productos en oferta estén definidos en el diccionario de precios, pues sino sería un problema tener un producto en oferta para el cual no sabemos su precio.

El invariante y las estructuras utilizadas en los niveles inferiores impactan directamente sobre las complejidades algorítmicas que se podrían conseguir en las funciones de la interfaz. Solo definen una cota inferior, ya que nuestros algoritmos siempre pueden hacer las cosas de forma ineficiente. Por ejemplo no usar nunca la propiedad del AVL y utilizar otra estrategia de balanceo más ineficiente. O en términos de conseguir la mejor complejidad posible, si la estructura utiliza un diccionario sobre lista enlazada, no vamos a poder obtener un significado en menos de $O(n)$ por la naturaleza misma de la lista enlazada (en el peor caso tenemos que recorrer toda la lista para encontrar la clave). Sin embargo, si la estructura utiliza un diccionario sobre un trie, podemos conseguir un significado en $O(|\text{clave}|)$ solo por haber utilizado otra estructura y las propiedades que su invariante garantiza.
